package plugin

import (
	"cmp"
	"fmt"
	"maps"
	"path"
	"path/filepath"
	"runtime"
	"slices"
	"strings"

	nexusv1 "github.com/bergundy/nexus-proto-annotations/go/nexus/v1"
	"github.com/dave/jennifer/jen"
	"github.com/spf13/pflag"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const nexusPkg = "github.com/nexus-rpc/sdk-go/nexus"
const nexusProtoPkg = "github.com/nexus-rpc/sdk-go/contrib/nexusproto"
const generatedFilenameExtension = "_nexus.pb.go"
const generatedPackageSuffix = "nexus"

var multiLineValues = jen.Options{
	Close:     "}",
	Multi:     true,
	Open:      "{",
	Separator: ",",
}

type Plugin struct {
	*protogen.Plugin
	version              string
	commit               string
	includeServiceTags   map[string]struct{}
	excludeServiceTags   map[string]struct{}
	includeOperationTags map[string]struct{}
	excludeOperationTags map[string]struct{}
	flags                *pflag.FlagSet
	messageNameToMessage map[protoreflect.FullName]*protogen.Message
}

func New(version, commit string) *Plugin {
	flags := pflag.NewFlagSet("plugin", pflag.ExitOnError)
	p := &Plugin{
		version:              version,
		commit:               commit,
		flags:                flags,
		messageNameToMessage: make(map[protoreflect.FullName]*protogen.Message),
	}
	flags.StringArray("include-service-tags", []string{}, "include only services with these tags")
	flags.StringArray("exclude-service-tags", []string{}, "exclude any services with these tags")
	flags.StringArray("include-operation-tags", []string{}, "include only operations with these tags")
	flags.StringArray("exclude-operation-tags", []string{}, "exclude any operations with these tags")

	return p
}

func (p *Plugin) Param(key, value string) error {
	return p.flags.Set(key, value)
}

func (p *Plugin) getTags(name string) (map[string]struct{}, error) {
	tags, err := p.flags.GetStringArray(name)
	if err != nil {
		return nil, fmt.Errorf("could not get include-tags flag: %w", err)
	}
	tagsMap := make(map[string]struct{}, len(tags))
	for _, t := range tags {
		tagsMap[t] = struct{}{}
	}
	return tagsMap, nil
}

func (p *Plugin) init() error {
	var err error
	if p.includeServiceTags, err = p.getTags("include-service-tags"); err != nil {
		return err
	}
	if p.excludeServiceTags, err = p.getTags("exclude-service-tags"); err != nil {
		return err
	}
	if p.includeOperationTags, err = p.getTags("include-operation-tags"); err != nil {
		return err
	}
	if p.excludeOperationTags, err = p.getTags("exclude-operation-tags"); err != nil {
		return err
	}
	return nil
}

func (p *Plugin) Run(plugin *protogen.Plugin) error {
	if err := p.init(); err != nil {
		return err
	}
	p.Plugin = plugin
	for _, file := range plugin.Files {
		for _, msg := range file.Messages {
			p.messageNameToMessage[msg.Desc.FullName()] = msg
		}
	}
	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}

		file.GoPackageName += generatedPackageSuffix
		prefixToSlash := filepath.ToSlash(file.GeneratedFilenamePrefix)
		file.GeneratedFilenamePrefix = path.Join(
			path.Dir(prefixToSlash),
			string(file.GoPackageName),
			path.Base(prefixToSlash),
		)
		importPath := path.Join(
			string(file.GoImportPath),
			string(file.GoPackageName),
		)

		f := jen.NewFilePathName(importPath, string(file.GoPackageName))
		p.genCodeGenerationHeader(f, file)

		var hasContent bool
		for _, svc := range file.Services {
			// Entire service excluded.
			if !p.shouldIncludeService(svc) {
				continue
			}
			// All methods excluded.
			if !slices.ContainsFunc(svc.Methods, func(m *protogen.Method) bool {
				return p.shouldIncludeOperation(m)
			}) {
				continue
			}
			hasContent = true
			p.genConsts(f, svc)
			p.genHandler(f, svc)
			p.genClient(f, svc)
		}

		if !hasContent {
			continue
		}

		if err := f.Render(
			p.Plugin.NewGeneratedFile(
				file.GeneratedFilenamePrefix+generatedFilenameExtension,
				protogen.GoImportPath(importPath),
			),
		); err != nil {
			return fmt.Errorf("error rendering file: %w", err)
		}
	}

	return nil
}

func (p *Plugin) genCodeGenerationHeader(f *jen.File, target *protogen.File) {
	f.PackageComment("Code generated by protoc-gen-go-nexus. DO NOT EDIT.")
	f.PackageComment("versions: ")
	f.PackageComment(fmt.Sprintf("    protoc-gen-go-nexus %s (%s)", p.version, p.commit))
	f.PackageComment(fmt.Sprintf("    go %s", runtime.Version()))
	if len(p.includeServiceTags) > 0 {
		f.PackageComment(fmt.Sprintf("include service tags: %s", strings.Join(slices.Collect(maps.Keys(p.includeServiceTags)), ", ")))
	}
	if len(p.excludeServiceTags) > 0 {
		f.PackageComment(fmt.Sprintf("exclude service tags: %s", strings.Join(slices.Collect(maps.Keys(p.excludeServiceTags)), ", ")))
	}
	if len(p.includeOperationTags) > 0 {
		f.PackageComment(fmt.Sprintf("include operation tags: %s", strings.Join(slices.Collect(maps.Keys(p.includeOperationTags)), ", ")))
	}
	if len(p.excludeOperationTags) > 0 {
		f.PackageComment(fmt.Sprintf("exclude operation tags: %s", strings.Join(slices.Collect(maps.Keys(p.excludeOperationTags)), ", ")))
	}
	compilerVersion := p.Plugin.Request.CompilerVersion
	if compilerVersion != nil {
		f.PackageComment(fmt.Sprintf("    protoc %s", compilerVersion.String()))
	} else {
		f.PackageComment("    protoc (unknown)")
	}

	f.PackageComment(fmt.Sprintf("source: %s", target.Desc.Path()))
}

func (p *Plugin) genConsts(f *jen.File, svc *protogen.Service) {
	svcNameConst := fmt.Sprintf("%sServiceName", svc.GoName)
	svcNameVal := cmp.Or(serviceOptions(svc).GetName(), string(svc.Desc.FullName()))
	f.Commentf("%s defines the fully-qualified name for the %s service.", svcNameConst, svcNameVal)
	f.Const().Id(svcNameConst).Op("=").Lit(svcNameVal)

	for _, method := range svc.Methods {
		if !p.shouldIncludeOperation(method) {
			continue
		}
		operationNameVal := cmp.Or(operationOptions(method).GetName(), method.GoName)
		nameConst := operationNameConst(svc, method)

		f.Commentf("%s defines the fully-qualified name for the %s operation.", nameConst, operationNameVal)
		f.Const().Id(nameConst).Op("=").Lit(operationNameVal)

		input, output := methodIO(method)
		f.Var().Id(operationVar(svc, method)).Op("=").Qual(nexusPkg, "NewOperationReference").Types(input, output).Call(jen.Id(nameConst))
	}
}

func (p *Plugin) genHandler(f *jen.File, svc *protogen.Service) {
	ifaceName := fmt.Sprintf("%sNexusHandler", svc.GoName)
	unimplementedHandlerName := fmt.Sprintf("Unimplemented%s", ifaceName)

	statements := []jen.Code{}

	for _, method := range svc.Methods {
		if !p.shouldIncludeOperation(method) {
			continue
		}
		input, output := methodIO(method)
		st := jen.Id(method.GoName).Params(jen.Id("name").String()).Qual(nexusPkg, "Operation").Types(
			input,
			output,
		)
		statements = append(statements, st)
	}
	f.Type().Id(ifaceName).Interface(statements...)

	f.Func().Id(fmt.Sprintf("New%sNexusService", svc.GoName)).Params(
		jen.Id("h").Id(ifaceName),
	).Params(jen.Op("*").Qual(nexusPkg, "Service"), jen.Error()).
		BlockFunc(func(g *jen.Group) {
			g.Id("svc").Op(":=").Qual(nexusPkg, "NewService").Call(jen.Id(fmt.Sprintf("%sServiceName", svc.GoName)))
			g.Id("err").Op(":=").Id("svc").Dot("Register").CallFunc(func(g *jen.Group) {
				for _, method := range svc.Methods {
					if !p.shouldIncludeOperation(method) {
						continue
					}
					g.Id("h").Dot(method.GoName).Call(jen.Id(operationNameConst(svc, method)))
				}
			})
			g.If().Id("err").Op("!=").Nil().Block(jen.Return().Nil().Op(",").Id("err"))
			g.Return().Id("svc").Op(",").Nil()
		})

	f.Type().Id(unimplementedHandlerName).Struct()

	for _, method := range svc.Methods {
		if !p.shouldIncludeOperation(method) {
			continue
		}
		input, output := methodIO(method)

		unimplementedOpHandlerName := fmt.Sprintf("unimplemented%s%s", svc.GoName, method.GoName)

		f.Type().Id(unimplementedOpHandlerName).Struct(
			jen.Qual(nexusPkg, "UnimplementedOperation").Types(input, output),
			jen.Id("name").String(),
		)

		f.Func().
			ParamsFunc(func(g *jen.Group) {
				g.Id("h").Op("*").Id(unimplementedOpHandlerName)
			}).
			Id("Name").
			Params().
			String().
			Block(
				jen.Return(jen.Id("h").Dot("name")),
			)

		f.Func().
			ParamsFunc(func(g *jen.Group) {
				g.Id("h").Op("*").Id(unimplementedHandlerName)
			}).
			Id(method.GoName).
			Params(jen.Id("name").String()).
			Qual(nexusPkg, "Operation").Types(input, output).
			Block(
				jen.Return().Op("&").Id(unimplementedOpHandlerName).CustomFunc(multiLineValues, func(g *jen.Group) {
					g.Id("name").Op(":").Id("name")
				}),
			)
	}
}

func (p *Plugin) genClient(f *jen.File, svc *protogen.Service) {
	structName := fmt.Sprintf("%sNexusHTTPClient", svc.GoName)
	f.Type().
		Id(structName).
		StructFunc(func(g *jen.Group) {
			g.Id("client").Qual(nexusPkg, "HTTPClient")
		})

	ctorName := fmt.Sprintf("New%sNexusHTTPClient", svc.GoName)
	f.Commentf("%s initializes a new %s.", ctorName, structName)
	f.Comment("options.Service is overridden with the defined proto service name.")
	f.Func().
		Id(ctorName).
		ParamsFunc(func(g *jen.Group) {
			g.Id("options").Qual(nexusPkg, "HTTPClientOptions")
		}).
		Params(
			jen.Op("*").Id(structName),
			jen.Error(),
		).
		BlockFunc(func(g *jen.Group) {
			g.Id("options").Dot("Service").Op("=").Id(fmt.Sprintf("%sServiceName", svc.GoName))
			g.If().Id("options").Dot("Serializer").Op("==").Nil().Block(
				jen.Id("options").Dot("Serializer").Op("=").Qual(nexusProtoPkg, "NewSerializer").Call(
					// TODO: this can be made configurable.
					jen.Qual(nexusProtoPkg, "SerializerOptions").CustomFunc(multiLineValues, func(g *jen.Group) {
						g.Id("Mode").Op(":").Qual(nexusProtoPkg, "SerializerModePreferJSON")
					}),
				),
			)
			g.Id("client").Op(",").Id("err").Op(":=").Qual(nexusPkg, "NewHTTPClient").Call(
				jen.Id("options"),
			)
			g.If(jen.Id("err").Op("!=").Nil()).Block(jen.Return(jen.Nil(), jen.Id("err")))
			g.Return(
				jen.Op("&").Id(structName).CustomFunc(multiLineValues, func(g *jen.Group) {
					g.Id("client").Op(":").Op("*").Id("client")
				}),
				jen.Nil(),
			)
		})

	for _, method := range svc.Methods {
		if !p.shouldIncludeOperation(method) {
			continue
		}
		input, output := methodIO(method)

		hasInput := method.Input.Desc.FullName() != "google.protobuf.Empty"
		hasOutput := method.Output.Desc.FullName() != "google.protobuf.Empty"
		asyncResultType := operationStartResult(svc, method)
		syncMethodName := method.GoName
		asyncMethodName := fmt.Sprintf("%sAsync", method.GoName)
		handleMethodName := fmt.Sprintf("New%sHandle", method.GoName)

		f.Type().Id(asyncResultType).StructFunc(func(g *jen.Group) {
			// TODO: document me.
			if hasOutput {
				g.Id("Successful").Add(output)
			}
			g.Id("Pending").Op("*").Qual(nexusPkg, "OperationHandle").Types(jen.Add(output))
			g.Id("Links").Op("[]").Qual(nexusPkg, "Link")
		})

		f.Func().
			ParamsFunc(func(g *jen.Group) {
				g.Id("c").Op("*").Id(structName)
			}).
			Id(asyncMethodName).
			ParamsFunc(func(g *jen.Group) {
				g.Id("ctx").Qual("context", "Context")
				if hasInput {
					g.Id("input").Add(input)
				}
				g.Id("options").Qual(nexusPkg, "StartOperationOptions")
			}).
			Params(
				jen.Op("*").Id(asyncResultType),
				jen.Error(),
			).
			BlockFunc(func(g *jen.Group) {
				g.Id("res").Op(",").Err().Op(":=").Qual(nexusPkg, "StartOperation").CallFunc(func(g *jen.Group) {
					g.Id("ctx")
					g.Op("&").Id("c").Dot("client")
					g.Id(operationVar(svc, method))
					if hasInput {
						g.Id("input")
					} else {
						g.Nil()
					}
					g.Id("options")
				})
				g.If().Err().Op("!=").Nil().Block(jen.Return(jen.Nil(), jen.Err()))

				g.Id("typed").Op(":=").Id(asyncResultType).BlockFunc(func(g *jen.Group) {
					if hasOutput {
						g.Id("Successful").Op(":").Id("res").Dot("Successful").Op(",")
					}
					g.Id("Pending").Op(":").Id("res").Dot("Pending").Op(",")
					g.Id("Links").Op(":").Id("res").Dot("Links").Op(",")
				})
				g.Return(jen.Op("&").Id("typed"), jen.Nil())
			})

		f.Func().
			ParamsFunc(func(g *jen.Group) {
				g.Id("c").Op("*").Id(structName)
			}).
			Id(syncMethodName).
			ParamsFunc(func(g *jen.Group) {
				g.Id("ctx").Qual("context", "Context")
				if hasInput {
					g.Id("input").Add(input)
				}
				g.Id("options").Qual(nexusPkg, "ExecuteOperationOptions")
			}).
			ParamsFunc(func(g *jen.Group) {
				if hasOutput {
					g.Add(output)
				}
				g.Error()
			}).
			BlockFunc(func(g *jen.Group) {
				call := jen.Qual(nexusPkg, "ExecuteOperation").CallFunc(func(g *jen.Group) {
					g.Id("ctx")
					g.Op("&").Id("c").Dot("client")
					g.Id(operationVar(svc, method))
					if hasInput {
						g.Id("input")
					} else {
						g.Nil()
					}
					g.Id("options")
				})

				if hasOutput {
					g.Id("output").Op(",").Id("err").Op(":=").Add(call)
					g.Return().Id("output").Op(",").Id("err")
				} else {
					g.Id("_").Op(",").Id("err").Op(":=").Add(call)
					g.Return().Id("err")
				}
			})

		f.Func().
			ParamsFunc(func(g *jen.Group) {
				g.Id("c").Op("*").Id(structName)
			}).
			Id(handleMethodName).
			Params(jen.Id("id").String()).
			Params(
				jen.Op("*").Qual(nexusPkg, "OperationHandle").Types(output),
				jen.Error(),
			).
			BlockFunc(func(g *jen.Group) {
				g.Return().Qual(nexusPkg, "NewHandle").CallFunc(func(g *jen.Group) {
					g.Op("&").Id("c").Dot("client")
					g.Id(operationVar(svc, method))
					g.Id("id")
				})
			})
	}
}

func (p *Plugin) shouldIncludeService(svc *protogen.Service) bool {
	tags := serviceOptions(svc).GetTags()
	if len(p.includeServiceTags) > 0 && !slices.ContainsFunc(tags, func(t string) bool {
		_, ok := p.includeServiceTags[t]
		return ok
	}) {
		return false
	}
	return !slices.ContainsFunc(tags, func(t string) bool {
		_, ok := p.excludeServiceTags[t]
		return ok
	})
}

func (p *Plugin) shouldIncludeOperation(m *protogen.Method) bool {
	tags := operationOptions(m).GetTags()
	if len(p.includeOperationTags) > 0 && !slices.ContainsFunc(tags, func(t string) bool {
		_, ok := p.includeOperationTags[t]
		return ok
	}) {
		return false
	}
	return !slices.ContainsFunc(tags, func(t string) bool {
		_, ok := p.excludeOperationTags[t]
		return ok
	})
}

func methodIO(method *protogen.Method) (*jen.Statement, *jen.Statement) {
	var input *jen.Statement
	if method.Input.Desc.FullName() != "google.protobuf.Empty" {
		input = jen.Op("*").Qual(string(method.Input.GoIdent.GoImportPath), method.Input.GoIdent.GoName)
	} else {
		input = jen.Qual(nexusPkg, "NoValue")
	}

	var output *jen.Statement
	if method.Output.Desc.FullName() != "google.protobuf.Empty" {
		output = jen.Op("*").Qual(string(method.Output.GoIdent.GoImportPath), method.Output.GoIdent.GoName)
	} else {
		output = jen.Qual(nexusPkg, "NoValue")
	}
	return input, output
}

func operationNameConst(svc *protogen.Service, method *protogen.Method) string {
	return fmt.Sprintf("%s%sOperationName", svc.GoName, method.GoName)
}

func operationVar(svc *protogen.Service, method *protogen.Method) string {
	return fmt.Sprintf("%s%sOperation", svc.GoName, method.GoName)
}

func operationStartResult(svc *protogen.Service, method *protogen.Method) string {
	return fmt.Sprintf("%s%sOperationStartResult", svc.GoName, method.GoName)
}

// operationOptions returns the OperationOptions for the given proto Method
func operationOptions(m *protogen.Method) *nexusv1.OperationOptions {
	opts, _ := proto.GetExtension(m.Desc.Options(), nexusv1.E_Operation).(*nexusv1.OperationOptions)
	return opts
}

// serviceOptions returns the ServiceOptions for the given proto Service
func serviceOptions(svc *protogen.Service) *nexusv1.ServiceOptions {
	opts, _ := proto.GetExtension(svc.Desc.Options(), nexusv1.E_Service).(*nexusv1.ServiceOptions)
	return opts
}
